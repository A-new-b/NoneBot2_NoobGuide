# 第二章：基础插件编写指南第四节———人家才懒得理你呢
本节中，将会学习 `priority` 优先级、简述事件阻断机制、`permission` 权限控制以及 `rule` 模块的使用。

## 本节前言
在接触到不少萌新开发者之后，我发现有不少新手的插件仅注重功能的实现，而不注重 “安全性” 方面的防范，导致机器人经常在群里被大家玩坏，导致账号风控甚至冻结。

我们首先来举几个例子，帮助大家了解一下为何我们要注重机器人的安全性：
1. 你写了一个涩图插件，那么在无内鬼的开车群里可以火力全开，但是在其他群聊里面你就会面临 “正义执行” 的举报，因此我们就需要限制发图频率甚至关闭插件保平安。
2. 你写了一个复读机插件，然后群里还有另外一个机器人也装了复读机插件，那么在触发条件之后这两个机器人很有可能就会互相刷屏，导致直接炸群。
3. 你写了一个爬虫插件，爬取的数据量较大，如果反复触发会导致网站封禁你的ip，这时你就需要过滤掉部分恶意请求。
4. 你写了一个群管插件，可以用于批量清人或禁言等敏感操作，这时你就需要设置仅由部分成员或管理员才能对机器人进行操作。

上述情况实质上的解决方法都是一种——屏蔽掉我们不希望被执行的请求，那么这章的工具将会是你的得力助手。

## priority 及 事件阻断

### priority
顾名思义，priority 为事件响应器优先级。在收到一条消息之后，nonebot会按照 `升序` 的方式逐一尝试使用每个事件响应器，直到事件被阻断（结束）或遍历完全部响应器。官方建议的 priority 取值范围为**大于等于1的正整数**。

>Tips：在nonebot的源码中，使用了 sorted() 函数对 priority 进行排序，也就是说理论上你加载的全部插件的 priorty 放到一个列表里后能够使用 sorted() 排序，那么理论上就不会报错。
这意味着你甚至可以传入不止大于等于1的正整数，你可以使用0、负数、浮点数甚至字符串（前提是全部 priority 都使用的是字符串）作为priority。但由于源码中某些**重要事件**的优先级为**0**，**小于等于0**的优先级很有可能会导致不可知的问题，请务必**不要**这么做！请一定要按照官方的建议，使用**大于等于1的正整数**作为插件的优先级。

聪明的你可能要提出一些疑问了：“为什么这个 priority 感觉和安全性关系不大呢？”，实际上也正是这样，priority 更多的会被应用在插件间的流程控制上，而配合起事件阻断机制可以对消息进行筛选，将事件拦截在触发之前。

### 简述事件阻断机制
>首先声明一点：这里仅是简述，可能会出现表述不严谨和过分简化的情况，请仅作为辅助理解。

在nonebot接收到事件并进行预处理之后，会将这个事件按照 priority 的顺序进行遍历，当以下情况之一发生的情况时，该事件将不会被继续处理：
1. 有任意事件响应器发出了阻止事件传递信号时。
2. 全部事件响应器均已传递完成，没有其他事件响应器可用。

也就是说，如果事件一直没有被阻断的话，可以被多个事件处理器接受并处理，相对的，如果事件被阻断了，后面的事件响应器即便能对该消息进行处理也不会被触发了。

举个例子：假设有人在群里发了张涩图，那么网速快的群友就能陆续收到这份涩图并开冲，然后被管理员 “OT警察” 看到了，认为影响不好，便撤回了涩图，那么后续的群友就无缘见到这张涩图了。

带入到nonebot的事件处理流程中，便是：机器人接收到消息后会生成一个事件，依次遍历事件响应器，优先级高一些的事件响应器可以更快的响应这个事件，直到某个事件响应器阻断了这个事件，那么后面的事件响应器就不会收到这个事件了。

目前，我们可以通过在事件响应器中添加 `block` 参数来指定该事件响应器是否会在执行完成后进行阻断，也可以在事件处理函数中使用 `matcher.stop_propagation()` 来直接阻断该事件

```py
from nonebot import on_message
from nonebot.matcher import Matcher

foo = on_message(priority=1, block=False)
@foo.handle()
async def handle(matcher: Matcher):
    matcher.stop_propagation()
```

>Tips: 
>1. `matcher.stop_propagation()` 会直接阻断该事件的传播，也会直接结束该事件的处理流程，类似于在函数中进行 `return` ，此后的代码将不会被执行。
>2. 不同的[辅助函数](https://v2.nonebot.dev/docs/tutorial/plugin/create-matcher#%E5%88%9B%E5%BB%BA%E4%BA%8B%E4%BB%B6%E5%93%8D%E5%BA%94%E5%99%A8)其默认block状态并不相同，因此请务必注意其阻断状态不会影响其他事件响应器的正常执行。

### 如何使用？
聪明的你一定想到了：我们可以通过设置一个**优先级最高**的事件响应器来检查全部的事件，对于不符合规范的事件可用通过**事件阻断机制进行屏蔽**。
实现起来也非常的简单，直接上代码：
```py
from nonebot import on_message
from nonebot.matcher import Matcher
from nonebot.adapters.onebot.v11 import Event

def can_pass(message):
    # 判断是否可以通过
    if 1==1:
        return True
    else:
        return False

bot_guard = on_message(priority=1, block=False) # block=False 即默认不阻断事件
@bot_guard.handle()
async def bot_guard_handle(matcher: Matcher,event: Event):
    message = str(event.get_message()) # 获取用户所发的消息内容
    if not can_pass(message):          # 如果返回值是False则阻断事件
        matcher.stop_propagation()
```

当然，在此基础上你可以添加依据群号、qq号、关键词和发言频率等一系列判断措施。

## permission
permission 


## rule模块



